Я отвечу как всемирно известный архитектор JavaFX-библиотек для карт, PhD по прикладной геоинформатике, лауреат ACM Software System Award.

**TL;DR**: Ниже — полностью переписанная спека под твои новые цели: без совместимости с оригиналом, минимальный и прямолинейный API, конфиг только через код, никакого дискового кэша и спец-событий в MVP. Она сразу готова к использованию как `IMPLEMENTATION_SPEC.md`.

---

````markdown
# JavaFX OSM Maps — Implementation Spec (MVP)

## 1. Введение

Цель проекта — реализовать простой и удобный для встраивания JavaFX-компонент для отображения карт OpenStreetMap на основе растровых тайлов.

MVP нацелен на:
- минимальный, но удобный публичный API;
- максимально простую конфигурацию (только через код, без system properties / ENV);
- архитектуру, которую легко расширить позже (альтернативные источники тайлов, кэш, события и т.п.), но без перегрузки первой версии.


## 2. Цели и ограничения MVP

### 2.1 Цели

1. Предоставить компонент `MapView` (JavaFX `Region`), который:
   - отображает карту на базе тайлов OSM (стандартный tile-сервер);
   - поддерживает панорамирование (drag мышью);
   - поддерживает масштабирование (колесо мыши, touch-zoom);
   - умеет плавно перелетать в указанную точку (`flyTo` с анимацией);
   - поддерживает несколько пользовательских слоёв (`MapLayer`).

2. Сделать API предельно простым:
   - без совместимости с существующими библиотеками;
   - без внешних конфигурационных файлов / system properties;
   - все настройки — только через код (конструкторы, параметры).

3. Обеспечить разумную производительность:
   - плавная работа при обычной нагрузке (цель — ~60 FPS при панорамировании и зуме на типичных десктопах);
   - ограниченная по памяти подгрузка тайлов (in-memory LRU-кэш).

4. Оставить понятные точки расширения:
   - возможность добавить дисковый кэш,
   - альтернативные источники тайлов,
   - расширенные события и слушатели,
   — но не реализовывать это в рамках MVP.


### 2.2 Не-цели MVP

MVP сознательно **не** решает:

- совместимость по API/поведению с какими-либо существующими библиотеками;
- поддержку векторных карт, стилей, роутинга, геокодинга;
- сложную систему конфигурации (system properties, ENV, файлы конфигурации, ServiceLoader, DI);
- дисковый кэш тайлов;
- сложные механики ввода (инерция, жесты «броска», горячие клавиши и т.п.);
- событийную модель поверх JavaFX-properties.

Все эти задачи могут появиться в будущих версиях.


## 3. Публичный API

Публичный API MVP состоит из следующих основных типов:

- `MapView` — основной компонент карты.
- `MapLayer` — базовый класс для пользовательских слоёв.
- `TileRetriever` — интерфейс загрузки тайлов.
- `TileCache` — интерфейс кэша тайлов.
- `SimpleOsmTileRetriever` — стандартная реализация `TileRetriever` для OSM.
- `InMemoryTileCache` — стандартная реализация `TileCache` (in-memory LRU).


### 3.1 MapView

```java
public final class MapView extends Region {

    // Конструктор по умолчанию: стандартный OSM-ретривер + стандартный LRU-кэш
    public MapView();

    // Конструктор с явной конфигурацией
    public MapView(TileRetriever retriever, TileCache cache);

    // Центр карты (широта и долгота, в градусах)
    public final DoubleProperty centerLatProperty();
    public final DoubleProperty centerLonProperty();

    public final double getCenterLat();
    public final void setCenterLat(double value);

    public final double getCenterLon();
    public final void setCenterLon(double value);

    // Масштаб карты (double, где целая часть совпадает с z-уровнем тайлов)
    public final DoubleProperty zoomProperty();

    public final double getZoom();
    public final void setZoom(double value);

    // Список слоёв, отрисовываемых поверх базовой карты
    public final ObservableList<MapLayer> getLayers();

    // Плавный перелёт к указанному положению
    public final void flyTo(double latitude,
                            double longitude,
                            double zoom,
                            Duration duration);
}
````

#### 3.1.1 Контракт координат

* `centerLat`:

  * тип: `double`,
  * диапазон: приблизительно [-85, +85] градусов (ограничения Web Mercator).
* `centerLon`:

  * тип: `double`,
  * диапазон: [-180, +180] градусов,
  * при выходе за диапазон долгота нормализуется (wrap-around).
* `zoom`:

  * тип: `double`,
  * минимальное значение: `0.0`,
  * максимальное значение (по умолчанию): `19.0` (может быть захардкожено или параметризовано конструктором позже),
  * при вычислении тайлов используется ближайшее целое (`zoomLevel = (int) Math.round(zoom)`).

Все изменения этих значений наблюдаемы через стандартные JavaFX-свойства (listeners, binding).

#### 3.1.2 Ввод и взаимодействие

Поведение по умолчанию:

* Левая кнопка мыши + drag — панорамирование карты.
* Колесо мыши — масштабирование:

  * zoom изменяется непрерывно (double),
  * масштабирование выполняется вокруг позиции курсора мыши.
* Touch / trackpad zoom (если поддерживается платформой) — масштабирование вокруг центра видимой области.

Все обработчики ввода реализуются внутри `MapView` и **не требуют** настройки для стандартного использования.

### 3.2 MapLayer

```java
public abstract class MapLayer extends Pane {

    // Вызывается MapView при необходимости переложить слой
    protected abstract void layoutLayer(MapView mapView);

    // Вызывается при добавлении слоя в MapView (по умолчанию no-op)
    protected void layerAdded(MapView mapView) { }

    // Вызывается при удалении слоя из MapView (по умолчанию no-op)
    protected void layerRemoved(MapView mapView) { }

    // Попросить MapView переложить слой на следующем кадре
    public final void requestLayerLayout();
}
```

#### 3.2.1 Работа со слоями

* Слои находятся в списке `mapView.getLayers()`.
* Порядок слоёв в списке определяет порядок отрисовки:

  * первый слой — ближе к «дну»,
  * последний — ближе всего к пользователю.
* При:

  * добавлении слоя в `getLayers()` — вызывается `layerAdded(mapView)`,
  * удалении — `layerRemoved(mapView)`.
* Внутри `MapView` при изменении `centerLat`, `centerLon` или `zoom` вызывается `layoutLayer(mapView)` для всех слоёв (не чаще, чем один раз за JavaFX pulse).

**Важно:** `layoutLayer` всегда вызывается на JavaFX Application Thread. Любые тяжёлые расчёты и I/O должны выполняться вне этого метода.

### 3.3 TileRetriever

```java
public interface TileRetriever {

    /**
     * Асинхронно загружает tile (z/x/y).
     *
     * @param zoom  целочисленный zoom-уровень
     * @param x     координата тайла по оси X
     * @param y     координата тайла по оси Y
     * @return future, завершающийся Image или исключением
     */
    CompletableFuture<Image> loadTile(int zoom, long x, long y);
}
```

Контракт:

* Метод не должен блокировать JavaFX Application Thread.
* Реализация может использовать внутренние пулы потоков.
* В случае ошибки `CompletableFuture` завершается с исключением (например, `IOException`).

### 3.4 TileCache

```java
public interface TileCache {

    /**
     * Возвращает изображение тайла или null, если тайл отсутствует в кэше.
     */
    Image get(int zoom, long x, long y);

    /**
     * Сохраняет изображение в кэш.
     */
    void put(int zoom, long x, long y, Image image);

    /**
     * Очищает кэш.
     */
    void clear();
}
```

Требования:

* Реализация должна быть потокобезопасной, т.к. кэш может использоваться из фоновых потоков.
* В MVP используется только in-memory реализация.

### 3.5 SimpleOsmTileRetriever

```java
public final class SimpleOsmTileRetriever implements TileRetriever {

    public SimpleOsmTileRetriever();

    public SimpleOsmTileRetriever(String baseUrl,
                                  String userAgent,
                                  Duration connectTimeout,
                                  Duration readTimeout);
}
```

Поведение по умолчанию:

* `baseUrl` по умолчанию: `https://tile.openstreetmap.org/{z}/{x}/{y}.png`
* `userAgent` — строка с названием библиотеки и версией (например, `javafx-osm-maps/0.1.0`).
* Используется HTTP-клиент (например, `java.net.http.HttpClient`) с заданными таймаутами.

Никаких системных свойств или переменных окружения для конфигурирования в MVP не используется — всё задаётся только через конструктор.

### 3.6 InMemoryTileCache

```java
public final class InMemoryTileCache implements TileCache {

    public InMemoryTileCache(int maxTiles);
}
```

Поведение:

* Хранит не более `maxTiles` элементов.
* При превышении лимита высвобождает место по LRU-стратегии (`Least Recently Used`).
* Использует потокобезопасную реализацию (например, `Collections.synchronizedMap` поверх `LinkedHashMap`).

## 4. Внутренняя архитектура (overview)

Следующие компоненты являются **внутренними** и не считаются частью стабильного публичного API MVP:

* `MapState` — модель состояния карты (центр, zoom, размер viewport-а, projection).
* `Projection` — интерфейс геопроекции (в MVP реализуется только Web Mercator).
* `TileManager` — компонент, управляющий загрузкой тайлов и обращениями к кэшу.
* Внутренние классы для анимации zoom/pan (`FlyToAnimation`, и т.п. — по усмотрению).

### 4.1 MapState

Основные поля:

* `double centerLat`;
* `double centerLon`;
* `double zoom`;
* `double viewportWidth`, `double viewportHeight`.

Основные методы:

* преобразование `lat/lon` → экранные координаты (x/y);
* расчет списка тайлов, видимых в текущем viewport;
* нормализация координат (ограничение широты, wrap долготы).

### 4.2 Projection (Web Mercator)

интерфейс (internal):

```java
interface Projection {

    Point2D latLonToPixel(double lat, double lon, int zoom);

    LatLon pixelToLatLon(double pixelX, double pixelY, int zoom);
}
```

В MVP реализуется только Web Mercator:

* преобразование в «глобальные» пиксели (`[0, 256 * 2^zoom)` по каждой оси);
* привязка тайлов к размеру 256×256 пикселей (константа).

### 4.3 TileManager

Ответственность:

* вычислить множество тайлов, необходимых для текущего состояния карты;
* проверить наличие каждого тайла в `TileCache`;
* для отсутствующих — инициировать загрузку через `TileRetriever`;
* хранить ссылку на готовые изображения для отрисовки;
* управлять отменой или игнорированием устаревших задач.

Примерный цикл:

1. При изменении `MapState` (центр/zoom/viewport) `TileManager` вычисляет список `TileKey { zoom, x, y }`.
2. Для каждого ключа:

   * сначала обращается к `TileCache.get(...)`;
   * если `null` — отправляет задачу в фоновой `ExecutorService` (общий для всех MapView) для вызова `retriever.loadTile(...)`.
3. Когда `CompletableFuture` завершается:

   * при успехе — изображение кладётся в `TileCache.put(...)` и помечается как доступное для отрисовки;
   * при ошибке — использовать placeholder-тайл.

### 4.3.1 Обработка устаревших задач

Чтобы не загружать ненужные тайлы при быстром перемещении:

* `TileManager` хранит «поколение» (`generation`) состояния карты.
* Каждая новая серия вычислений видимой области увеличивает поколение.
* Задача загрузки тайла помечается поколением на момент старта.
* По завершении `CompletableFuture`:

  * если поколение задачи < текущего поколения менеджера — результат игнорируется;
  * если равно — используется.

Отмена на уровне HTTP-клиента в MVP опциональна; достаточно игнорировать «старые» результаты.

## 5. Потоки и исполнение задач

### 5.1 ExecutorService

В MVP используется один общий для библиотеки пул потоков:

```java
final class TileExecutors {
    static final ExecutorService TILE_EXECUTOR =
        Executors.newFixedThreadPool(Math.max(2, Runtime.getRuntime().availableProcessors()));
}
```

Особенности:

* Пул создаётся лениво при первом использовании (первый `MapView`).
* Пул живёт до завершения JVM (graceful shutdown не требуется в MVP).
* Все сетевые вызовы и обработка изображений выполняются в этом пуле.
* Вызовы, затрагивающие JavaFX UI (например, установка текстуры на `ImageView`), выполняются через `Platform.runLater(...)`.

## 6. Работа с ошибками и placeholder-тайлами

### 6.1 Политика ошибок

В MVP:

* Нет специализированных событий/слушателей ошибок.
* Ошибки загрузки тайлов (сеть, HTTP, декодирование) обрабатываются внутри `TileManager`:

  * логируются (через стандартный `Sl4j`);
  * тайл в отображении заменяется placeholder-изображением.

### 6.2 Placeholder

Вариант по умолчанию:

* простое однотонное изображение (например, светло-серое, размер 256×256);
* генерируется один раз и переиспользуется для всех проблемных тайлов.

В будущих версиях можно добавить возможность задавать placeholder через API, но в MVP это не требуется.

## 7. Тестирование

### 7.1 Unit-тесты

Обязательные юнит-тесты:

* **Проекция и MapState**:

  * корректная конверсия `lat/lon` ↔ пиксели на нескольких уровнях zoom;
  * корректные ограничения широты и wrap долготы.
* **Расчёт видимых тайлов**:

  * набор тайлов для фиксированных center/zoom/viewport;
  * корректная обработка границ мира (при переходе через 180°).
* **InMemoryTileCache**:

  * корректное LRU-поведение;
  * потокобезопасный доступ (параллельные `get/put`).
* **TileManager (частично)**:

  * правильный запрос кэша;
  * игнорирование результатов от устаревших поколений.

### 7.2 Интеграционные тесты

* Создание `MapView` в тестовом JavaFX-приложении.
* Проверка:

  * что при заданном center/zoom отображается корректный набор тайлов;
  * что при drag/zoom тайлы подгружаются и не возникает явных утечек (по профилированию).

Для MVP достаточно ручных интеграционных проверок с простым тестовым приложением.

## 8. План расширений после MVP (non-blocking)

MVP архитектурно готов к следующим расширениям без ломки основного API:

1. **Дисковый кэш тайлов**:

   * реализация `TileCache` поверх файловой системы;
   * ограничение по размеру на диске и TTL.

2. **Альтернативные источники тайлов**:

   * дополнительные реализации `TileRetriever` (например, другие URL-форматы, ключи API).

3. **Расширенная событийная модель**:

   * события изменения центра и zoom через отдельные listener-интерфейсы;
   * события ошибок загрузки тайлов.

4. **Расширенная конфигурация**:

   * перегруженные конструкторы `MapView` с дополнительными параметрами;
   * опциональный конфигурационный объект (например, `MapsConfig`).

5. **Расширенные жесты и UX**:

   * инерция при панорамировании;
   * double-click-to-zoom;
   * жесты клавиатурой.

Эти расширения не входят в MVP и не должны усложнять текущую реализацию.

## 9. Итог

Данный документ описывает минимальную, но расширяемую архитектуру библиотеки JavaFX OSM Maps для MVP:

* один простой `MapView`;
* минимальный API для слоёв (`MapLayer`);
* простой интерфейс загрузки тайлов (`TileRetriever`) и in-memory кэш (`TileCache`);
* стандартный `SimpleOsmTileRetriever` и `InMemoryTileCache`;
* отсутствие внешних конфигураций и спец-событий в первой версии.

Он может использоваться как основа для реализации и как справочный документ по договорённостям в команде.
