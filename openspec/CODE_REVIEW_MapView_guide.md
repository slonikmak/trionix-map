# MapView / MapLayer Code Review & Guidelines

Этот документ основан на ревью текущего кода (`MapView`, `MapState`, `TileManager`, `TileExecutors`, `MapLayer`, тестовый harness) и фиксирует основные выводы по качеству, архитектуре и производительности, а также рекомендации по написанию новых `MapLayer`.

## 1. Архитектура

- **Чёткое разделение ответственности**
  - `MapView` — публичный JavaFX-компонент, отвечающий за отрисовку тайлов, слоёв и обработку пользовательского ввода.
  - `MapState` — чистый объект состояния вьюпорта (центр, зум, размер) плюс расчёт набора видимых тайлов.
  - `TileManager` — координация кэша, асинхронной загрузки тайлов и инвалидации поколениями (generation-based invalidation).
  - `TileExecutors` — общий виртуальный executor (Java 21 `newVirtualThreadPerTaskExecutor`) для загрузки и декодирования тайлов.
  - `MapLayer` — базовый класс для оверлеев, которые располагаются поверх карты.

- **Потоковая модель**
  - Все изменения сцены JavaFX происходят на FX-потоке; при необходимости используются `Platform.runLater(...)` и проверки через `Platform.isFxApplicationThread()` / `ensureFxThread(...)`.
  - `TileManager` гарантирует, что колбэк `TileConsumer` вызывается на FX-потоке, независимо от того, откуда пришёл результат загрузки.
  - `MapView.flyTo(...)` принимает вызовы с любого потока и сам маршаллит в FX-поток.
  - Начиная с Java 21, фоновые задачи по загрузке/декодированию тайлов выполняются во виртуальных потоках, создаваемых через общий `TileExecutors`.

- **Расширяемость**
  - Слоистая модель через `MapLayer` позволяет добавлять произвольные оверлеи, не меняя внутренностей `MapView`.
  - `TileRetriever` и `TileCache` внедряются через конструктор, что позволяет подменять источник тайлов и стратегию кэширования.
  - Детали проекции (`Projection`/`WebMercatorProjection`) инкапсулированы внутри `internal`-пакетов.

- **Зоны для потенциального улучшения**
  - `MapView` довольно насыщен логикой (UI, жесты, анимации, координация слоёв). По мере роста функционала можно вынести обработку ввода/жестов в отдельный класс-контроллер, чтобы упростить `MapView`.
  - Нормализация координат (`clampLatitude`, `normalizeLongitude`, `clampZoom`) выполняется и в `MapView.createNormalizedProperty(...)`, и в `MapState`. В будущем можно централизовать ответственность за нормализацию (например, доверять `MapState`).
  - `TileExecutors` использует общий виртуальный executor. Для библиотечного кода это удобно, но при интеграции в крупные приложения может понадобиться возможность подменить executor внешним или ограничить количество in-flight задач.

## 2. Качество кода

- **Читаемость и стиль**
  - Говорящие имена методов и полей: `visibleTiles`, `pruneTileImages`, `zoomAroundPoint`, `alignCenterToFocus`, `requestLayerLayout` и т.д.
  - JavaDoc не только описывает назначение, но и подчёркивает требования по потокам (FX thread only), диапазоны значений и инварианты.
  - Широкое использование `Objects.requireNonNull` с осмысленными сообщениями.

- **Инкапсуляция и API**
  - Публичный API `MapView` минимален и ориентирован на типичный сценарий использования: центр, зум, список слоёв, анимация `flyTo`.
  - Внутренние классы находятся в `internal`-пакетах и помечены `final`, что уменьшает риск непредусмотренного наследования.

- **Тестируемость**
  - Юнит-тесты закрывают ключевые компоненты: состояние карты, менеджер тайлов, анимации, интеграционную работу `MapView`, систему слоёв и утилиты.
  - `FxTestHarness` и `MapViewTestHarness` упрощают работу с JavaFX в headless-тестах: гарантируют инициализацию `Platform` и безопасное выполнение кода на FX-потоке.

- **Небольшие косметические замечания**
  - Форматирование объявления свойств в `MapView` можно унифицировать (отступы/пустые строки), чтобы поддерживать единый стиль по проекту.

## 3. Производительность

- **Проекции и расчёт тайлов**
  - `MapState.visibleTiles()` рассчитывает прямоугольный набор тайлов, соответствующий текущему центру, зуму и размеру вьюпорта. Память под список тайлов резервируется заранее, что минимизирует перераспределения.
  - Количество тайлов по оси X учитывает оборачивание (wrap) по долготе, что даёт бесшовный скролл по миру.

- **Загрузка и кэширование тайлов**
  - `TileManager.refreshTiles(...)` устраняет дубликаты через `LinkedHashSet` — нет лишних запросов к кэшу и сети.
  - Ведётся поколенческий счётчик `generation`; результаты старых поколений отбрасываются и не отображаются, что предотвращает «артефакты» при быстром скролле/зуме.
  - Кэш работает на уровне расшифрованных `Image`, уменьшает количество декодирований.

- **Отрисовка**
  - В `MapView.drawTiles(...)` каждый кадр очищает канвас и рисует только текущий набор видимых тайлов. Логика проста и предсказуемо быстрая для типичных размеров.
  - Для каждого кадра вычисляется центр в пикселях ровно один раз, далее координаты тайлов считаются арифметически — это минимизирует нагрузку на `Projection`.

- **Потенциальные точки оптимизации (по результатам профилирования)**
  - На каждый `refreshTiles` создаётся новый список `List<TileCoordinate>` и новый `HashSet` в `pruneTileImages(...)`. При очень большом количестве событий и крупном вьюпорте это может создать заметную нагрузку на GC. Возможные оптимизации:
    - Переиспользовать изменяемый список/множество (pooling) на уровне `MapView`/`MapState`.
    - Использовать `retainAll` для `tileImages.keySet()`, если это не ухудшит читаемость.
  - `TileExecutors` теперь создаёт задачи на виртуальных потоках. Это снимает лимит на количество блокирующих запросов, но повышает требования к контролю за in-flight тайлами и отменами в `TileManager`.

---

## 4. Guideline по написанию новых `MapLayer`

Ниже — рекомендации по проектированию новых реализаций `MapLayer` с учётом производительности и потоковой модели JavaFX.

### 4.1. Общие принципы

- **Слой — это пассивный «виджет» над картой**
  - `MapLayer` не должен сам управлять состоянием карты (`setCenterLat`, `setZoom` и т.п.) без явной необходимости.
  - Основная ответственность `MapLayer` — визуализация данных в координатах карты/экрана.

- **Минимизировать работу в `layoutLayer(MapView)`**
  - Метод `layoutLayer` вызывается на каждый JavaFX-пульс, когда карта требует переразметки. Здесь не должно быть тяжёлой логики:
    - Никаких блокирующих I/O.
    - Минимум аллокаций и вычислений, которые можно кэшировать.
    - Без долгих циклов, если это можно вынести в подготовительный шаг.
  - Хорошая стратегия: в `layoutLayer` делать только пересчёт позиций/видимости уже подготовленных узлов.

- **Чётко разделять данные и представление**
  - Данные слоя (модели объектов) лучше хранить в своих структурах (коллекции, immutable объекты), а JavaFX-узлы (Node) — как отображение (view) этих данных.
  - При изменении данных:
    - Обновлять внутреннюю модель.
    - Вызывать `requestLayerLayout()` (см. ниже).
    - В `layoutLayer` пересчитать и применить изменения к узлам.

### 4.2. Работа с FX-потоком

- **Все модификации сцены — только на FX-потоке**
  - Любые вызовы, которые меняют JavaFX-узлы (`getChildren().add(...)`, изменение свойств узлов и т.п.), должны выполняться на FX-потоке.
  - Если слой получает данные из фонового потока (например, результаты вычислений или сетевых запросов), он должен использовать `Platform.runLater(...)` для переноса изменений в FX.

- **Используйте `requestLayerLayout()` вместо прямого `requestLayout()`**
  - `requestLayerLayout()` уже заботится о том, чтобы вызвать `requestLayout` у `MapView` на FX-потоке.
  - Рекомендуемый паттерн:
    - Модель данных меняется (в любом потоке).
    - Слой вызывает `requestLayerLayout()`.
    - На следующем пульсе `MapView` вызывает `layoutLayer(...)`, где слой аккуратно применяет изменения.

- **Жизненный цикл слоя**
  - Переопределяйте `layerAdded(MapView mapView)` и `layerRemoved(MapView mapView)` для инициализации/освобождения ресурсов:
    - В `layerAdded` — подписки на Observable-данные, подготовка кэшированных структур и т.п.
    - В `layerRemoved` — отписка от событий, остановка фоновых задач, очистка временных объектов.
  - Эти методы также вызываются на FX-потоке.

### 4.3. Производительность слоёв

- **Избегайте избыточных нод**
  - Большое количество JavaFX-узлов (тысячи и более) сильно влияет на производительность layout/рендера.
  - По возможности:
    - Используйте один канвас (`Canvas`) внутри слоя и рисуйте на нём primitives, вместо большого количества `Circle`, `Rectangle` и т.п.
    - Группируйте объекты логически и визуально (clusterization) на больших масштабах.

- **Кэшируйте то, что можно кэшировать**
  - Повторно используйте узлы при панорамировании/зуме, вместо их создания/удаления на каждом кадре.
  - Вычисления, которые зависят только от статических данных (например, геометрия объектов на фиксированном зуме), можно подготовить один раз и потом только корректировать позицию.

- **Стабильная сложность layout-а**
  - Старайтесь, чтобы время выполнения `layoutLayer` росло линейно с числом реально видимых объектов, а не со всеми объектами в модели.
  - Отфильтровывайте невидимые элементы (по bounding box в координатах карты) до того, как будете обновлять их представление.

### 4.4. Работа с координатами и MapView

- **Получение текущего состояния карты**
  - Из `MapView` можно читать:
    - `getCenterLat()`, `getCenterLon()`, `getZoom()` — для понимания общего положения карты.
    - Размер слоя (`getWidth()`, `getHeight()`), который соответствует размеру вьюпорта.
  - Если слойу нужны координаты пикселей/проекции (например, чтобы привязать маркеры к тайлам), разумно добавить в `MapLayer` или вспомогательный утилитный класс функции, использующие ту же `Projection`, что и `MapView`.

- **Не дублировать проекцию**
  - По возможности избегайте параллельной реализации проекции и логики расчёта тайлов в слое.
  - Лучше переиспользовать уже имеющиеся механизмы (через публичные методы/утилиты либо добавить небольшой API в `MapView`/`MapState`, если это действительно нужно).

### 4.5. Ошибки и диагностика

- **Защита от неправильного использования**
  - Внутри `MapLayer` проверяйте, что слой привязан к карте, если это требуется для операции: `getMapView()` может вернуть `null`, пока слой не добавлен в `MapView`.
  - При обнаружении неправильного вызова (например, попытка использовать карту, когда она не привязана) — выбрасывайте понятное исключение или корректно игнорируйте операцию.

- **Логирование**
  - Для сложных слоёв имеет смысл использовать логирование для диагностики тяжёлых операций (например, прогрев кэша, крупные пересчёты геометрии) и аномальных ситуаций.

---

Этот документ можно расширять по мере появления новых типов слоёв и требований к производительности. При добавлении сложных оверлеев (heatmap, кластеризация маркеров, динамическая маршрутизация) рекомендуется сначала описать архитектурный подход на уровне `MapLayer`/утилит, а затем уже переходить к реализации.